<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes">
  <title>will you be my valentine? üíò</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', 'Comic Sans MS', 'Chalkboard SE', cursive, sans-serif;
    }
    body {
      min-height: 100vh;
      background: linear-gradient(145deg, #ffb6c1 0%, #ff9eb5 30%, #ffccd9 100%);
      background-attachment: fixed;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      position: relative;
      overflow-x: hidden;
    }
    /* floating hearts background */
    .heart-bg {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    .heart-bg span {
      position: absolute;
      font-size: 1.8rem;
      opacity: 0.5;
      color: #ff4d6d;
      animation: float 7s infinite ease-in-out;
      user-select: none;
    }
    @keyframes float {
      0% { transform: translateY(0vh) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(10deg); }
      100% { transform: translateY(0vh) rotate(0deg); }
    }
    /* teddy, chocolates, balloons ‚Äì as decorative floating elements */
    .deco {
      position: fixed;
      pointer-events: none;
      z-index: 2;
      filter: drop-shadow(0 8px 12px rgba(0,0,0,0.1));
    }
    #teddy {
      bottom: 10px;
      left: 5px;
      font-size: 3.5rem;
      transform: rotate(-5deg);
      animation: wobble 6s infinite;
    }
    #chocolate1 {
      top: 30px;
      right: 15px;
      font-size: 3rem;
      transform: rotate(15deg);
      animation: sway 5s infinite;
    }
    #chocolate2 {
      bottom: 50px;
      right: 25px;
      font-size: 3rem;
      transform: rotate(-10deg);
      animation: sway 7s infinite reverse;
    }
    .balloon {
      font-size: 3rem;
      position: fixed;
      animation: floatBalloon 9s infinite;
    }
    #balloon1 {
      top: 5%;
      left: 2%;
      font-size: 3.2rem;
      animation-delay: 0s;
    }
    #balloon2 {
      top: 15%;
      right: 1%;
      font-size: 3.5rem;
      animation-delay: 1.5s;
      transform: scaleX(-1);
    }
    #balloon3 {
      bottom: 20%;
      left: 15%;
      font-size: 3rem;
      animation-delay: 3s;
    }
    @keyframes wobble {
      0%,100% { transform: rotate(-5deg) translateY(0); }
      50% { transform: rotate(0deg) translateY(-8px); }
    }
    @keyframes sway {
      0%,100% { transform: rotate(15deg) translateX(0); }
      50% { transform: rotate(5deg) translateX(-5px); }
    }
    @keyframes floatBalloon {
      0% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-25px) rotate(5deg); }
      100% { transform: translateY(0px) rotate(0deg); }
    }
    /* main card */
    .valentine-card {
      position: relative;
      z-index: 20;
      background: rgba(255, 245, 245, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 56px 56px 46px 46px;
      padding: 40px 24px 40px 24px;
      max-width: 440px;
      width: 100%;
      box-shadow: 0 30px 45px -20px rgba(180, 30, 60, 0.5),
                  inset 0 2px 8px rgba(255,255,255,0.7);
      border: 2px solid rgba(255,255,255,0.7);
      text-align: center;
    }
    h1 {
      font-size: 2.1rem;
      line-height: 1.3;
      color: #a12b4a;
      text-shadow: 2px 2px 0 #ffccd5;
      margin-bottom: 32px;
      font-weight: 900;
      letter-spacing: -0.5px;
      word-break: break-word;
      background: rgba(255, 255, 255, 0.3);
      padding: 12px 8px;
      border-radius: 70px;
      display: inline-block;
      width: auto;
      margin-left: auto;
      margin-right: auto;
      backdrop-filter: blur(4px);
      box-shadow: 0 4px 10px rgba(255, 140, 170, 0.3);
    }
    .button-panel {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 24px;
      margin: 30px 0 20px;
      position: relative;
    }
    .btn {
      border: none;
      background: white;
      padding: 16px 32px;
      font-size: 1.8rem;
      font-weight: bold;
      border-radius: 60px;
      box-shadow: 0 12px 0 #b33b5c, 0 8px 18px rgba(190, 40, 80, 0.4);
      cursor: pointer;
      transition: all 0.1s ease;
      min-width: 140px;
      letter-spacing: 2px;
      border: 3px solid #ffeef2;
      color: #b34160;
      text-shadow: 0 1px 2px #ffeef2;
      touch-action: manipulation; /* improve mobile */
    }
    .btn:active {
      transform: translateY(8px);
      box-shadow: 0 4px 0 #b33b5c, 0 8px 18px rgba(190, 40, 80, 0.4);
    }
    /* yes button */
    .btn-yes {
      background: #ff8aae;
      color: #4a0010;
      box-shadow: 0 10px 0 #a12244, 0 8px 18px #c94f6f;
    }
    /* no button - special moving container */
    .no-wrapper {
      position: relative;
      display: inline-block;
      transition: transform 0.2s ease;
      z-index: 50;
    }
    .btn-no {
      background: #4a2b34;
      color: #ffd9e2;
      box-shadow: 0 10px 0 #2f1b21, 0 8px 18px #3d232b;
      border: 3px solid #ffb6c1;
      cursor: default; /* visually button but actual click is prevented by pointer-events? we move it */
      /* but we want no click: we will manage via pointer-events: none? but then hover won't work on wrapper.
         we use js to move it away on hover/mouseenter, but on mobile we need "touchstart" to move it */
    }
    /* no button actual text is still there, but we control movement via wrapper */
    /* message after yes */
    .secret-msg {
      margin-top: 36px;
      font-size: 2rem;
      font-weight: bold;
      color: #8f1e40;
      background: rgba(255, 220, 230, 0.7);
      backdrop-filter: blur(5px);
      padding: 22px 12px;
      border-radius: 80px;
      border: 3px dashed #ff98a8;
      text-shadow: 2px 2px 0 #ffb8c6;
      display: none;
      word-break: break-word;
      animation: pop 0.5s;
    }
    @keyframes pop {
      0% { transform: scale(0.7); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .secret-msg.show {
      display: block;
    }
    /* additional hearts and candies inside card */
    .inline-hearts {
      font-size: 2rem;
      line-height: 1;
      margin: 10px 0 -10px;
      letter-spacing: 10px;
    }
    /* mobile fine-tuning */
    @media (max-width: 420px) {
      h1 { font-size: 1.9rem; }
      .btn { font-size: 1.5rem; padding: 14px 20px; min-width: 120px; }
      .secret-msg { font-size: 1.7rem; }
      #teddy { font-size: 2.8rem; }
    }
    /* for hover devices we move no button */
    /* default: no movement until hover event triggers JS */
  </style>
</head>
<body>
  <!-- background floating hearts (randomly placed) -->
  <div class="heart-bg" id="heartBg"></div>

  <!-- valentine decorations: teddy, chocolates, balloons (fixed) -->
  <div class="deco" id="teddy">üß∏‚ù§Ô∏è</div>
  <div class="deco" id="chocolate1">üç´üç´</div>
  <div class="deco" id="chocolate2">üç¨üç¨</div>
  <div class="balloon" id="balloon1">üéà‚ù§Ô∏è</div>
  <div class="balloon" id="balloon2">üéÄüéà</div>
  <div class="balloon" id="balloon3">üéàüßÅ</div>

  <!-- main card -->
  <div class="valentine-card">
    <div class="inline-hearts">‚ù§Ô∏è üß° üíõ</div>
    <h1>will you be my valentine?</h1>
    
    <div class="button-panel">
      <!-- YES button normal -->
      <button class="btn btn-yes" id="yesBtn">YES</button>
      
      <!-- NO button with wrapper to move around -->
      <div class="no-wrapper" id="noWrapper">
        <button class="btn btn-no" id="noBtn">NO</button>
      </div>
    </div>
    
    <!-- hidden message appears after clicking yes -->
    <div class="secret-msg" id="secretMsg">hehe, my pookie will always be my pookie ‚ù§Ô∏èüß∏</div>
    
    <div class="inline-hearts">üíñ üç´ üíù</div>
  </div>

  <script>
    (function() {
      // ---------- background hearts generator ----------
      const bgContainer = document.getElementById('heartBg');
      const heartSymbols = ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'ü©∑', 'üíò', 'üíù', '‚ù§Ô∏è‚Äçüî•', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì'];
      for (let i = 0; i < 24; i++) {
        const span = document.createElement('span');
        span.innerText = heartSymbols[Math.floor(Math.random() * heartSymbols.length)];
        const size = Math.floor(Math.random() * 30 + 20) + 'px'; // random size
        span.style.fontSize = (Math.random() * 2.2 + 1.2) + 'rem';
        span.style.left = Math.random() * 100 + '%';
        span.style.top = Math.random() * 100 + '%';
        span.style.animationDelay = (Math.random() * 5) + 's';
        span.style.opacity = Math.random() * 0.4 + 0.2;
        span.style.transform = `rotate(${Math.random()*30-15}deg)`;
        bgContainer.appendChild(span);
      }

      // ---------- moving "NO" button logic (mobile & desktop) ----------
      const noWrapper = document.getElementById('noWrapper');
      const noBtn = document.getElementById('noBtn');
      const yesBtn = document.getElementById('yesBtn');
      const secretMsg = document.getElementById('secretMsg');
      
      // ensure no button itself doesn't capture clicks (we move it so it's effectively unclickable)
      // but if someone taps very fast on mobile where it doesn't move, we still want to prevent any "click" on no
      noBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        // also move a bit extra on click just in case, but we will also move on touchstart
        moveNoButton();
        return false;
      });

      // function to move the noWrapper to a random location within button panel
      function moveNoButton() {
        const panel = document.querySelector('.button-panel');
        const panelRect = panel.getBoundingClientRect();
        const wrapperRect = noWrapper.getBoundingClientRect();
        
        // max offsets so wrapper stays inside panel (with some margin)
        const maxX = panelRect.width - wrapperRect.width - 10;
        const maxY = panelRect.height - wrapperRect.height - 10;
        
        if (maxX <= 0 || maxY <= 0) return; // avoid edge
        
        // random delta relative to current position? better to set absolute position inside panel
        // we can use transform relative to its current position but that may go out of panel.
        // Use absolute positioning inside panel (panel is relative). We'll set wrapper position: absolute within panel.
        // But panel has display:flex, so we need to make wrapper positioned absolutely.
        // We change button panel style to relative if not already, and no-wrapper to absolute.
        panel.style.position = 'relative';
        noWrapper.style.position = 'absolute';
        noWrapper.style.left = 'auto';
        noWrapper.style.right = 'auto';
        noWrapper.style.top = 'auto';
        noWrapper.style.bottom = 'auto';
        
        // compute safe random coordinates inside panel
        let newLeft = Math.random() * maxX;
        let newTop = Math.random() * maxY;
        
        // but we need to keep it away from YES button? not necessary, just fun.
        noWrapper.style.left = newLeft + 'px';
        noWrapper.style.top = newTop + 'px';
      }

      // reset movement on window resize so wrapper doesn't get stuck out of panel
      function resetNoPosition() {
        noWrapper.style.position = 'relative';
        noWrapper.style.left = 'auto';
        noWrapper.style.top = 'auto';
        // re-adjust later on next hover
      }

      // attach movement to mouseenter (desktop hover)
      noWrapper.addEventListener('mouseenter', function(e) {
        moveNoButton();
      });

      // for mobile: touchstart on wrapper moves it immediately (finger aiming for no)
      noWrapper.addEventListener('touchstart', function(e) {
        e.preventDefault();  // prevent any possible click through
        moveNoButton();
      }, { passive: false });

      // also on touchmove inside wrapper? we can also move again to be safe, but touchstart is enough
      // but if user drags finger, we also want to escape:
      noWrapper.addEventListener('touchmove', function(e) {
        e.preventDefault();
        moveNoButton();
      }, { passive: false });

      // additionally, when user tries to click on no button (the inner button) we move it and prevent any action
      noBtn.addEventListener('mousedown', function(e) {
        e.preventDefault();
        moveNoButton();
      });
      noBtn.addEventListener('touchstart', function(e) {
        e.preventDefault();
        moveNoButton();
      }, { passive: false });

      // also move when finger touches anywhere inside noWrapper (already done)
      
      // make sure we can't click no by any chance: stop propagation on noBtn
      noBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        moveNoButton();
        return false;
      });

      // on window resize, reset to relative to avoid misplacement
      window.addEventListener('resize', () => {
        resetNoPosition();
      });

      // ---------- YES button shows message ----------
      yesBtn.addEventListener('click', () => {
        secretMsg.classList.add('show');
        // also sprinkle some joy: hide no button a little? just for fun: we can also disable no movement, but not necessary
        // maybe make no wrapper semi-transparent? optional
        noWrapper.style.opacity = '0.3';
        noBtn.disabled = true; // for extra measure, but we still keep movement
        // but message appears, fine.
      });

      // also ensure that if user clicks yes multiple times, it stays
      // extra: if user somehow clicks no after yes, we keep moving but no effect
      
      // Preload initial position as relative. Reset on orientation change
      window.addEventListener('orientationchange', function() {
        setTimeout(() => {
          resetNoPosition();
        }, 50);
      });

      // additional decoration: clicking on teddy or balloons does nothing, just fun
      // also to make the moving button more entertaining on mobile, we move on any attempt to touch near no
      // for extra sneakiness, also move on touchmove over document?
      // but let's keep it simple, already moves on touchstart on wrapper.

      // final precaution: if any click/tap somehow registers on noBtn, we block it
      noBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        moveNoButton();
      });
      noBtn.addEventListener('pointermove', (e) => {
        // on some devices, pointermove might be used; we can move on that too, but may be excessive
        // but fine, we use only hover and touchstart.
      });
      
      // done.
    })();
  </script>

  <!-- additional inline styles for button panel position context -->
  <style>
    .button-panel {
      position: relative;
      min-height: 130px;
    }
    .no-wrapper {
      transition: left 0.15s ease, top 0.15s ease; /* smooth movement */
      will-change: left, top;
      z-index: 100;
    }
    /* for mobile we ensure wrapper is large enough to tap */
    .btn-no {
      pointer-events: none; /* we don't want the button to swallow events; we want wrapper to handle all */
      /* but wrapper receives events, then button visual is safe. We want hover/touch on wrapper to trigger movement. */
      /* so we keep pointer-events as default (auto) on wrapper? wrapper is the div, its children button can have pointer-events: none? */
      /* Actually if button has pointer-events: none, then wrapper will receive all touch/mouse events, perfect. */
    }
    /* Update: set noBtn pointer-events to none, so all events go to noWrapper */
    #noBtn {
      pointer-events: none;
    }
    /* make wrapper area same size as button for easier catching */
    .no-wrapper {
      display: inline-block;
    }
    /* make sure button still visible */
    .btn-no {
      margin: 0; /* as normal */
    }
    /* for easier hit area on mobile, we can increase wrapper padding? but button size is fine */
  </style>

  <!-- extra little script to ensure pointer events none set (we already did in style) -->
</body>
</html>